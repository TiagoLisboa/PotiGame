tipo AstarNode
	x, y, p: Inteiro
	var g, h, f = -1
fim

tipo Astar
	start, end: Ponto
	livre: Ponto => Lógico   # função para saber se um ponto está livre
	start_node = AstarNode(start.x.inteiro, start.y.inteiro, 0)
  dest_node =  AstarNode(end.x.inteiro, end.y.inteiro, 0)
	var open_nodes := [start_node]
	empty_list = open_nodes.cauda
	var closed_nodes := empty_list

	heuristica(c, d: AstarNode) = abs(c.x - d.x) + abs(c.y - d.y)

	custo(c, d: AstarNode) = 10

	expanda(c: AstarNode) = [
		Ponto(c.x    , c.y - 1),  # norte
    Ponto(c.x    , c.y + 1),  # sul
    Ponto(c.x + 1, c.y    ),  # leste
    Ponto(c.x - 1, c.y    )   # oeste
  ]

  menor_f() # procura o nó com menor valor f
  	var low_i := 1
  	para i de 1 até open_nodes.tamanho faça
	  	se open_nodes[i].f < open_nodes[low_i].f então
		  	low_i := i
		  fim
	  fim
    retorne low_i
  fim

  caminho(node, dest_node: AstarNode)
  	var path := [dest_node]
		var current_node := node
  	enquanto current_node.p <> 0 faça
	  	current_node := closed_nodes[current_node.p]
		  path := current_node :: path
	  fim
    retorne path
  fim

  in_closed(vx, vy: Inteiro) = closed_nodes.selecione(cn => vx == cn.x e vy == cn.y).tamanho > 0
	in_open(vx, vy: Inteiro)   = open_nodes.selecione(cn => vx == cn.x e vy == cn.y).tamanho > 0

  incluir_vizinhos(current_node: AstarNode)
		neighbor_nodes = expanda(current_node)
		para vizinho em neighbor_nodes faça
			vx		= vizinho.x.inteiro
			vy		= vizinho.y.inteiro

			se (livre(Ponto(vx, vy)) ou (vx == dest_node.x e vy == dest_node.y)) e
			      não in_closed(vx, vy) e não in_open(vx, vy) então
				new_node = AstarNode(vx, vy, - closed_nodes.tamanho)
				new_node.g := current_node.g + custo(current_node, new_node)
				new_node.h := heuristica(new_node, dest_node)
				new_node.f := new_node.g + new_node.h

        open_nodes := new_node :: open_nodes
			fim
		fim
	fim

	encontra_rota()
  	var resp := empty_list
		enquanto open_nodes.tamanho > 0 e resp.tamanho == 0 faça
			best_node = menor_f
			current_node = open_nodes[best_node]
			se (current_node.x == dest_node.x) e (current_node.y == dest_node.y) então
				resp := caminho(current_node, dest_node)
			senão
  			open_nodes := open_nodes.remova(best_node)
  			closed_nodes := current_node :: closed_nodes
				incluir_vizinhos(current_node)
			fim
		fim
		retorne resp.mapeie(n => Ponto(n.x, n.y))
	fim
fim
